<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xxliud.github.io</id>
    <title>Zcbb - Workspace</title>
    <updated>2020-07-02T10:32:22.994Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xxliud.github.io"/>
    <link rel="self" href="https://xxliud.github.io/atom.xml"/>
    <subtitle>念念不忘，必有回响</subtitle>
    <logo>https://xxliud.github.io/images/avatar.png</logo>
    <icon>https://xxliud.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Zcbb - Workspace</rights>
    <entry>
        <title type="html"><![CDATA[Vue - Router专题]]></title>
        <id>https://xxliud.github.io/post/vue-router/</id>
        <link href="https://xxliud.github.io/post/vue-router/">
        </link>
        <updated>2020-07-02T10:11:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="解读routerindexjs文件">解读router/index.js文件</h1>
<pre><code class="language-javascript">import Vue from 'vue'
import Router from 'vue-router'
import store from '@/store'
import axios from 'axios'
import myTest from '@/router/modules/myTest'

axios.defaults.withCredentials = true;

Vue.use(Router)

let router = new Router({
  routes: [{
    path: '/',
    component: resolve =&gt; require(['@/layout.vue'], resolve),
    redirect: '/myTest',
    children: [
      ...myTest
    ]
  }, {
    path: '/login',
    component: resolve =&gt; require(['@/pages/login.vue'], resolve)
  }]
})

router.beforeEach((to, from, next) =&gt; {
  let isLogin = store.state.token;
  if (isLogin == null) {
    console.log(isLogin);
    if (to.path !== '/login') {
      return next({
        path: '/login'
      });
    } else {
      next();
    }
  } else {
    if (to.path === '/login') {
      return next({
        path: '/index'
      });
    }
    next();
  }
});

//====change page title after route change

router.afterEach((to, from) =&gt; {
  axios.post(`/api-traceback/api/visitor/insertOne`, {
    source: &quot;flow&quot;,
    username: store.state.user.username,
    url: to.fullPath
  }).then((response) =&gt; {})
});

export default router
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue - Vuex Store专题]]></title>
        <id>https://xxliud.github.io/post/vue-vuex/</id>
        <link href="https://xxliud.github.io/post/vue-vuex/">
        </link>
        <updated>2020-06-30T12:11:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vuex-store是什么">Vuex Store是什么？</h1>
<p>vuex store 是vue的状态管理模块，vuex store 是响应式的，当vue组件从store中读取状态（state）时，若store中的状态发生更新时，会及时的响应给其他的组件。<br>
store 中的四个核心选项:     state mutations  getters  actions</p>
<h1 id="核心思想">核心思想</h1>
<ul>
<li>state<br>
state是用来存放组件之间共享的数据，一般会在组件的计算属性中获取state的数据。<br>
调用方法： this.$store.state.[属性name]，只有读属性，没有写属性。</li>
</ul>
<pre><code class="language-javascript">//  '@/store/index.js'
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  modules: {
    user
  }
});

//  '@/pages/myTest/myTest.vue
export default {
  name: 'myTest',
  components: {},
  data() {
    return {
      token: this.$store.state.token
    };
  }
  }
</code></pre>
<ul>
<li>mutations<br>
在 Vuex store 中，实际改变 状态(state) 的唯一方式是通过提交(commit) 一个 mutation。<br>
在组件里提交： this.$store.commit('change', payload)<br>
mutations下的函数接收state作为参数，接收一个叫做payload（载荷）的东西作为第二个参数，这个东东是用来记录开发者使用该函数的一些信息，比如说提交了什么，提交的东西是用来干什么的，包含多个字段，所以载荷一般是对象。</li>
</ul>
<pre><code class="language-javascript">//  '@/store/index.js'
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  modules: {
    user
  }
});

//  '@/store/mutations.js
let mutations = {
  // 计数器
  addCount(state, num) {
    if (num) {
      state.count += num;
    }
  }
}

//  '@/pages/myTest/myTest.vue'
export default {
  computed: {
    this.$store.commit('addCount', 2)
  }
}
</code></pre>
<ul>
<li>getters<br>
getters可以看成是store的计算属性。<br>
getters下的函数接收state作为第一个参数。getters可以过滤组件中的数据，过滤的数据会存放到$store.getters对象中。</li>
</ul>
<pre><code class="language-javascript">//  '@/store/index.js'
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  getters: getters,
  modules: {
    user
  }
});

//  '@/store/getters.js
let getters = {
  // 计数器
  getCount(state) {
      return state.count
  }
}

//  '@/pages/myTest/myTest.vue'
export default {
  data: {
      count: this.$store.state.getount();
  }
}
</code></pre>
<ul>
<li>actions<br>
actions：类似于mutation ，但是mutations只能处理同步函数，而actions则是可以处理任何的异步操作。</li>
</ul>
<pre><code class="language-javascript">//  '@/store/index.js'
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  getters: getters,
  actions: actions,
  modules: {
    user
  }
});

//  '@/store/action.js
let actions = {
  // 计数器
  getInfo({
    commit
  }, params) {
    commit('updateMail', params.mail);
    commit('updatePhone', params.phone)
  }
}

//  '@/pages/myTest/myTest.vue'
export default {
  computed: {
    this.$store.dispath('getInfo', {'mail': '327xxx@qq.com', 'phone': '139xxxxxxx'})
  }
}
</code></pre>
<p>💡actions和mutations的区别<br>
1.Actions 提交的是 mutations，而不是直接变更状态。也就是说，actions会通过mutations，让mutations帮他提交数据的变更。<br>
2.Action 可以包含任意异步操作。</p>
<h1 id="store-分层">Store 分层</h1>
<p>分享一下我项目中store的层级关系<br>
<img src="https://xxliud.github.io/post-images/1593523832808.png" alt="" loading="lazy"></p>
<pre><code class="language-shell">-- store
--- modules  # 模块化
---- user.js   # store.user
--- index.js   # store实例
--- actions_type.js   # actons type list
--- mutations_type.js  # mutations type list
--- mutations.js   # store -&gt; mutations
</code></pre>
<p>项目内并未使用getters，大部分计算属性都放到了vue的computed里了</p>
<ul>
<li>index.js 定义store实例</li>
</ul>
<pre><code class="language-javascript"> // '@/store/index.js'
import Vue from 'vue';
import Vuex from 'vuex';
import mutations from '@/store/mutations';
import user from './modules/user.js'

Vue.use(Vuex);

//=======vuex store start===========
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  modules: {
    user
  }
});
//=======vuex store end===========
export default store
</code></pre>
<ul>
<li>mutations.js 定义模块外state的一些变更方法</li>
</ul>
<pre><code class="language-javascript">let mutations = {
  // 计数器
  addCount(state, num) {
    if (num) {
      state.count += num;
    }
  }
}
export default mutations
</code></pre>
<ul>
<li>mutations_type.js 定义module里mutations的类别</li>
</ul>
<pre><code class="language-javascript">//user.js
export const SAVE_USER_USERNAME = &quot;SAVE_USER_USERNAME&quot;
export const SAVE_USER_DISPLAYNAME = &quot;SAVE_USER_DISPLAYNAME&quot;
export const SAVE_USER_MAIL = &quot;SAVE_USER_MAIL&quot;
export const SAVE_USER_PHONE = &quot;SAVE_USER_PHONE&quot;
export const SAVE_USER_ROLE = &quot;SAVE_USER_ROLE&quot;
export const SAVE_USER_TOKEN = &quot;SAVE_USER_TOKEN&quot;
</code></pre>
<ul>
<li>actions_type.js 定义module里actions的类别</li>
</ul>
<pre><code class="language-javascript">//user.js
export const COMPUTED_INFO = &quot;COMPUTED_INFO&quot;
</code></pre>
<ul>
<li>modules/user.js 定义一个模块user</li>
</ul>
<pre><code class="language-javascript">import {
  GET_USER_MESSAGE,
  SAVE_USER_USERNAME,
  SAVE_USER_DISPLAYNAME,
  SAVE_USER_MAIL,
  SAVE_USER_PHONE,
  SAVE_USER_ROLE,
  SAVE_USER_TOKEN
} from '@/store/mutations_type.js'
import {
  COMPUTED_INFO
} from '@/store/actions_type.js'
import axios from 'axios'
axios.defaults.withCredentials = true;
import router from '@/router';

const state = {
  username: '',
  displayName: '',
  mail: '',
  phone: '',
  role: '',
  projectTree: '',
  token: ''
}

const getters = {

}

const mutations = {
  [SAVE_USER_TOKEN]: (state, value) =&gt; {
    state.token = value
  },
  [SAVE_USER_USERNAME]: (state, value) =&gt; {
    state.username = value
  },
  [SAVE_USER_DISPLAYNAME]: (state, value) =&gt; {
    state.displayName = value
  },
  [SAVE_USER_MAIL]: (state, value) =&gt; {
    state.mail = value
  },
  [SAVE_USER_PHONE]: (state, value) =&gt; {
    state.phone = value
  },
  [SAVE_USER_ROLE]: (state, value) =&gt; {
    state.role = value
  }
}

const actions = {
  [COMPUTED_INFO]: ({
    commit
  }, params) =&gt; {
    commit(SAVE_USER_MAIL, params.mail);
    commit(SAVE_USER_PHONE, params.phone)
  },
  getUserInfo({
    commit
  }, params) {
    commit(SAVE_USER_MAIL, params.mail);
    commit(SAVE_USER_PHONE, params.phone)
  }
}

export default {
  namespaced: true,   // 一定要有这个key, 定义命名空间用的，否则外面找不到
  state,
  mutations,
  actions
}
</code></pre>
<ul>
<li>vue中如何酸爽的使用？</li>
</ul>
<ol start="2">
<li>获取state属性</li>
</ol>
<pre><code class="language-javascript">export default {
  name: 'myTest',
  components: {},
  data() {
    return {
      token: this.$store.state.token   // 粗暴方法
    };
  },
  computed: {
    ...mapState({
      count: state =&gt; state.count   // 优雅方法
    })
  }
</code></pre>
<ol>
<li>执行mutations</li>
</ol>
<pre><code class="language-javascript">mounted() {
    this.changeUserName(&quot;zcbb...2017&quot;);  // 优雅方法
    this.$store.user.commit(&quot;SAVE_USER_USERNAME&quot;, &quot;zcbb...2015&quot;);  // 粗暴方法
  },
  watch: {},
  created() {},
  methods: {
    ...mapMutations({
      changeUserName: &quot;user/SAVE_USER_USERNAME&quot;
    })
}
</code></pre>
<ol start="3">
<li>执行actions</li>
</ol>
<pre><code class="language-javascript">mounted() {
    this.actionUserInfo({         // 优雅方法   
      &quot;mail&quot;: &quot;visir.liu@qq.com&quot;,
      &quot;phone&quot;: &quot;17694806300&quot;
    });
    this.$store.user.dispath(&quot;COMPUTED_INFO&quot;, {     // 粗暴方法
      &quot;mail&quot;: &quot;visir.liu@qq.com&quot;,
      &quot;phone&quot;: &quot;17694806300&quot;
    })
  },
watch: {},
created() {},
methods: {
...mapActions({
    actionUserInfo: &quot;user/COMPUTED_INFO&quot;
    })
}
</code></pre>
<p>至此vuex store介绍完毕..</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue - 野路子大全]]></title>
        <id>https://xxliud.github.io/post/vue-knowledge/</id>
        <link href="https://xxliud.github.io/post/vue-knowledge/">
        </link>
        <updated>2020-06-24T14:29:12.000Z</updated>
        <content type="html"><![CDATA[<p>[ * ] <a href="https://xxliud.github.io/post/vue-vuex" title="vue-store">vue-store</a><br>
[ * ] <a href="https://xxliud.github.io/post/vue-router" title="vue-router">vue-router</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - 金丝雀发布]]></title>
        <id>https://xxliud.github.io/post/k8s-gray/</id>
        <link href="https://xxliud.github.io/post/k8s-gray/">
        </link>
        <updated>2020-06-23T16:16:43.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>确认istio-ingressgateway是否有对外的IP</li>
</ul>
<pre><code class="language-shell">kubectl get  service istio-ingressgateway -n istio-system
</code></pre>
<ul>
<li>编辑EXTERNAL-IP，写入ClusterIP为外网ip</li>
</ul>
<pre><code class="language-shell">kubectl edit  service istio-ingressgateway -n istio-system
</code></pre>
<ul>
<li>建立deployment</li>
</ul>
<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-app-1
spec:
  replicas: 1
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: &quot;true&quot;
      labels:
        app: nginx-app
        version: v1
    spec:
      containers:
        - name: nginx-app-1
          image: datacenter:v0.0.1
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 80
---

apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-app-2
spec:
  replicas: 1
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: &quot;true&quot;
      labels:
        app: nginx-app
        version: v2
    spec:
      containers:
        - name: nginx-app-2
          image: datacenter:v0.0.2
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 80
</code></pre>
<ul>
<li>建立service</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
  labels:
    svcname: nginx-svc
spec:
  ports:
  - port: 8088
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx-app
</code></pre>
<ul>
<li>建立gateway</li>
</ul>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: nginx-gateway
spec:
  selector:
    istio: ingressgateway # use Istio default gateway implementation
  servers:
  - port:
      number: 80
      name: nginx-http
      protocol: HTTP
    hosts:
    - istio-zcbb.com
</code></pre>
<ul>
<li>建立VirtualService</li>
</ul>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: nginx-vs
spec:
  hosts:
  - istio-zcbb.com
  gateways:
  - nginx-gateway
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: nginx-svc
        subset: v1
      weight: 70
    - destination:
        host: nginx-svc
        subset: v2
      weight: 30
</code></pre>
<ul>
<li>建立DestinationRule</li>
</ul>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: nginx-app
spec:
  host: nginx-svc
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
</code></pre>
<pre><code class="language-shell">Istio Virtual Service，用于控制当前deployment和金丝雀deployment流量分配的权重
Istio Destination Rule，包含当前deployment和金丝雀deployment的子集（subset）
Istio Gateway（可选），如果服务需要从容器集群外被访问则需要搭建gateway
</code></pre>
<p>至此最简单的金丝雀发布完成，后期可以定制各种灰度策略</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s- 蓝绿发布]]></title>
        <id>https://xxliud.github.io/post/k8s-blue-green/</id>
        <link href="https://xxliud.github.io/post/k8s-blue-green/">
        </link>
        <updated>2020-06-23T16:05:29.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>实现原理，多pod，切换service verson指向</li>
<li>启动两个版本的deployment</li>
</ul>
<pre><code class="language-yaml">--- service 指向v1
apiVersion: v1
kind: Service
metadata:
  name: demo
  namespace: default
  labels:
    app: demo
spec:
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app: demo
    version: v1
--- depliyment v1
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo1-deployment
  namespace: default
  labels:
    app: demo
    version: v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: demo
      version: v1
  template:
    metadata:
      labels:
        app: demo
        version: v1
    spec:
      containers:
      - name: demo1
        image: database:v0.01
        ports:
          - name: http
            containerPort: 80
            protocol: TCP

--- depliyment v2
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo2-deployment
  namespace: default
  labels:
    app: demo
    version: v2
spec:
  replicas: 1
  selector:
    matchLabels:
      app: demo
      version: v2
  template:
    metadata:
      labels:
        app: demo
        version: v2
    spec:
      containers:
      - name: demo2
        image: database:v0.02
        ports:
          - name: http
            containerPort: 80
            protocol: TCP
</code></pre>
<ul>
<li>切换入口流量从v1 到 v2</li>
</ul>
<pre><code class="language-shell">kubectl patch service demo -p '{&quot;spec&quot;:{&quot;selector&quot;:{&quot;version&quot;:&quot;v2&quot;}}}'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - 安装ELK]]></title>
        <id>https://xxliud.github.io/post/k8s-elk/</id>
        <link href="https://xxliud.github.io/post/k8s-elk/">
        </link>
        <updated>2020-06-23T15:25:28.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>创建namespace elk</li>
</ul>
<pre><code class="language-shell">kubectl create namespace elk
</code></pre>
<ul>
<li>创建elasticsearch deployment service</li>
</ul>
<pre><code class="language-yaml">--- # elasticsearch deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: elasticsearch
  namespace: elk
  labels:
    app: elasticsearch
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
        hostname: elasticsearch
        containers:
         - image: elasticsearch:6.8.4
           imagePullPolicy: IfNotPresent
           name: elasticsearch
           ports:
             - name: es-port
               containerPort: 9200
             - name: es-tran-port
               containerPort: 9300

--- # elasticsearch service
apiVersion: v1
kind: Service
metadata:
  name: elasticsearch
  namespace: elk
  labels:
    name: elasticsearch
spec:
  type: NodePort
  ports:
  - port: 9200
    targetPort: 9200
    protocol: TCP
    nodePort: 30011
  selector:
    app: elasticsearch
</code></pre>
<ul>
<li>创建logstash deployment service, 配置文件参考之前文章</li>
</ul>
<pre><code class="language-yaml">--- # logstash deploy
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-logstash
  namespace: elk
  labels:
    app: my-logstash
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-logstash
  template:
    metadata:
      labels:
        app: my-logstash
    spec:
      containers:
        - name: my-logstash
          image: logstash:6.8.4
          imagePullPolicy: IfNotPresent
          ports:
          - containerPort: 5044
          volumeMounts:
          - name: log-config
            mountPath: /usr/share/pipeline
      volumes:
       - name: log-config
         hostPath:
          path: /Users/xingxu/elk/logstash/pipeline

--- # logstash service
apiVersion: v1
kind: Service
metadata:
  name: my-logstash
  namespace: elk
  labels:
    name: my-logstash
spec:
  type: NodePort
  ports:
  - port: 5044
    targetPort: 5044
    protocol: TCP
    nodePort: 30012
  selector:
    app: my-logstash
</code></pre>
<ul>
<li>创建kibana deployment service</li>
</ul>
<pre><code class="language-yaml">--- # kibana deploy
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-kibana
  namespace: elk
  labels:
    app: my-kibana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-kibana
  template:
    metadata:
      labels:
        app: my-kibana
    spec:
      containers:
        - name: my-kibana
          image: kibana:6.8.4
          imagePullPolicy: IfNotPresent
          ports:
          - containerPort: 5601

--- # kibana service
apiVersion: v1
kind: Service
metadata:
  name: my-kibana
  namespace: elk
  labels:
    name: my-kibana
spec:
  type: NodePort
  ports:
  - port: 5601
    targetPort: 5601
    protocol: TCP
    nodePort: 30010
  selector:
    app: my-kibana
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - zk&kafka安装]]></title>
        <id>https://xxliud.github.io/post/k8s-zk-kafka/</id>
        <link href="https://xxliud.github.io/post/k8s-zk-kafka/">
        </link>
        <updated>2020-06-23T14:56:48.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>创建zookerper deployment service</li>
</ul>
<pre><code class="language-yaml">--- # zk deploy
kind: Deployment
apiVersion: apps/v1
metadata:
  name: my-zk
  namespace: base
  labels:
    app: my-zk
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-zk
  template:
    metadata:
      labels:
        app: my-zk
    spec:
      hostname: my-zk
      dnsPolicy: ClusterFirst
      containers:
      - name: my-zk
        image: zookeeper
        imagePullPolicy: IfNotPresent
        volumeMounts:
        ports:
        - containerPort: 2181
        - containerPort: 2888
        - containerPort: 3888

### zk service
---
apiVersion: v1
kind: Service
metadata:
  name: my-zk
  namespace: base
  labels:
    name: my-zk
spec:
  type: NodePort
  ports:
  - port:
    port: 2181
    targetPort: 2181
    protocol: TCP
        nodePort: 30001
  selector:
    app: my-zk
</code></pre>
<ul>
<li>创建kafka deployment service</li>
</ul>
<pre><code class="language-yaml">--- # kafka deploy
kind: Deployment
apiVersion: apps/v1
metadata:
  name: my-kafka
  namespace: base
  labels:
    app: my-kafka
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-kafka
  template:
    metadata:
      labels:
        app: my-kafka
    spec:
      hostname: my-kafka
      dnsPolicy: ClusterFirst
      containers:
      - name: my-kafka
        image: wurstmeister/kafka
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 9092
        env:
        - name: KAFKA_ZOOKEEPER_CONNECT
          value: 'my-zk.base:2181'
        - name: KAFKA_ADVERTISED_HOST_NAME
          value: 'ClusterIP'
        - name: KAFKA_ADVERTISED_PORT
          value: 'NodePort'

--- # kafka service
apiVersion: v1
kind: Service
metadata:
  name: my-kafka
  namespace: base
  labels:
    name: my-kafka
spec:
  type: NodePort
  ports:
  - port: 9092
    targetPort: 9092
    protocol: TCP
    nodePort: 30002
  selector:
    app: my-kafka
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - Mongo安装篇]]></title>
        <id>https://xxliud.github.io/post/k8s-mongo/</id>
        <link href="https://xxliud.github.io/post/k8s-mongo/">
        </link>
        <updated>2020-06-23T14:38:49.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>创建namespace</li>
</ul>
<pre><code class="language-shell">kubectl create namespace base
</code></pre>
<ul>
<li>创建deployment service</li>
</ul>
<pre><code class="language-yaml">--- # mongo deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-mongo
  namespace: base
  labels:
    app: my-mongo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-mongo
  template:
    metadata:
      labels:
        app: my-mongo
    spec:
      containers:
      - name: my-mongo
        image: mongo
        ports:
        - containerPort: 27017

---  # mongo service
apiVersion: v1
kind: Service
metadata:
  name: my-mongo
  namespace: base
  labels:
    name: my-mongo
spec:
  type: NodePort
  ports:
  - port: 27017
    targetPort: 27017
    protocol: TCP
    nodePort: 30000
  selector:
    app: my-mongo
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - 学习资料汇总]]></title>
        <id>https://xxliud.github.io/post/k8s/</id>
        <link href="https://xxliud.github.io/post/k8s/">
        </link>
        <updated>2020-06-23T12:52:02.000Z</updated>
        <content type="html"><![CDATA[<p>[ * ] <a href="https://xxliud.github.io/post/minikube-install" title="minikube-install">Mac Install Minikube</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-mongo" title="k8s-mongo">K8s Install Mongo</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-zk-kafka" title="k8s-zk-kafka">K8s Install Zookerper Kafka</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-elk" title="k8s-elk">K8s Install ELK</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-istio" title="k8s-istio">Install Istio</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-blue-green" title="k8s-blue-green">K8s Bule Green Release</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-gray" title="k8s-gary">K8s Gray Release</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - Minikube安装篇]]></title>
        <id>https://xxliud.github.io/post/minikube-install/</id>
        <link href="https://xxliud.github.io/post/minikube-install/">
        </link>
        <updated>2020-06-23T12:52:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是k8s">什么是k8s</h2>
<p>我们知道，我们可以将项目制作成docker镜像，然后利用docker去部署我们的项目，这样可以解决很多服务器环境所带来的问题；<br>
但是容器多了，容器与容器之间就需要访问，之间就需要网络配置等等，从而就有了docker-compose；<br>
但是当我们的服务进行升级，或者服务需要进行调度，扩容等等，这个时候就需要一个大管家来管所有的东西；<br>
这个大管家就是 - Kubernetes</p>
<h2 id="mac安装kubernetes单节点minikube">mac安装kubernetes单节点minikube</h2>
<ul>
<li>安装kubectl 核心操作管理命令</li>
</ul>
<pre><code class="language-shell">brew install kubernetes-cli
</code></pre>
<ul>
<li>安装minikube</li>
</ul>
<pre><code class="language-shell">brew cask install minikube
</code></pre>
<ul>
<li>启动minikube</li>
</ul>
<pre><code class="language-shell">minikube start -p docker镜像仓库
Starting local Kubernetes v1.10.0 cluster...
Starting VM...
Getting VM IP address...
Moving files into cluster...
Setting up certs...
Connecting to cluster...
Setting up kubeconfig...
Starting cluster components...
Kubectl is now configured to use the cluster.
Loading cached images from config file.
</code></pre>
<ul>
<li>查看kubernetes的dashboard</li>
</ul>
<pre><code class="language-shell">minikube dashboard
</code></pre>
<p>至此minikube搭建完成</p>
]]></content>
    </entry>
</feed>