<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xxliud.github.io</id>
    <title>Zcbb - Workspace</title>
    <updated>2020-06-30T13:20:18.258Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xxliud.github.io"/>
    <link rel="self" href="https://xxliud.github.io/atom.xml"/>
    <subtitle>念念不忘，必有回响</subtitle>
    <logo>https://xxliud.github.io/images/avatar.png</logo>
    <icon>https://xxliud.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Zcbb - Workspace</rights>
    <entry>
        <title type="html"><![CDATA[Vue - Vuex Store专题]]></title>
        <id>https://xxliud.github.io/post/vue-vuex/</id>
        <link href="https://xxliud.github.io/post/vue-vuex/">
        </link>
        <updated>2020-06-30T12:11:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vuex-store是什么">Vuex Store是什么？</h1>
<p>vuex store 是vue的状态管理模块，vuex store 是响应式的，当vue组件从store中读取状态（state）时，若store中的状态发生更新时，会及时的响应给其他的组件。<br>
store 中的四个核心选项:     state mutations  getters  actions</p>
<h1 id="核心思想">核心思想</h1>
<ul>
<li>state<br>
state是用来存放组件之间共享的数据，一般会在组件的计算属性中获取state的数据。<br>
调用方法： this.$store.state.[属性name]，只有读属性，没有写属性。</li>
</ul>
<pre><code class="language-javascript">//  '@/store/index.js'
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  modules: {
    user
  }
});

//  '@/pages/myTest/myTest.vue
export default {
  name: 'myTest',
  components: {},
  data() {
    return {
      token: this.$store.state.token
    };
  }
  }
</code></pre>
<ul>
<li>mutations<br>
在 Vuex store 中，实际改变 状态(state) 的唯一方式是通过提交(commit) 一个 mutation。<br>
在组件里提交： this.$store.commit('change', payload)<br>
mutations下的函数接收state作为参数，接收一个叫做payload（载荷）的东西作为第二个参数，这个东东是用来记录开发者使用该函数的一些信息，比如说提交了什么，提交的东西是用来干什么的，包含多个字段，所以载荷一般是对象。</li>
</ul>
<pre><code class="language-javascript">//  '@/store/index.js'
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  modules: {
    user
  }
});

//  '@/store/mutations.js
let mutations = {
  // 计数器
  addCount(state, num) {
    if (num) {
      state.count += num;
    }
  }
}

//  '@/pages/myTest/myTest.vue'
export default {
  computed: {
    this.$store.commit('addCount', 2)
  }
}
</code></pre>
<ul>
<li>getters<br>
getters可以看成是store的计算属性。<br>
getters下的函数接收state作为第一个参数。getters可以过滤组件中的数据，过滤的数据会存放到$store.getters对象中。</li>
</ul>
<pre><code class="language-javascript">//  '@/store/index.js'
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  getters: getters,
  modules: {
    user
  }
});

//  '@/store/getters.js
let getters = {
  // 计数器
  getCount(state) {
      return state.count
  }
}

//  '@/pages/myTest/myTest.vue'
export default {
  data: {
      count: this.$store.state.getount();
  }
}
</code></pre>
<ul>
<li>actions<br>
actions：类似于mutation ，但是mutations只能处理同步函数，而actions则是可以处理任何的异步操作。</li>
</ul>
<pre><code class="language-javascript">//  '@/store/index.js'
const store = new Vuex.Store({
  state: {
    token: null,
    count: 0
  },
  mutations: mutations,
  getters: getters,
  actions: actions,
  modules: {
    user
  }
});

//  '@/store/action.js
let actions = {
  // 计数器
  getInfo({
    commit
  }, params) {
    commit('updateMail', params.mail);
    commit('updatePhone', params.phone)
  }
}

//  '@/pages/myTest/myTest.vue'
export default {
  computed: {
    this.$store.dispath('getInfo', {'mail': '327xxx@qq.com', 'phone': '139xxxxxxx'})
  }
}
</code></pre>
<h1 id="actions和mutations的区别">actions和mutations的区别：</h1>
<p>1.Actions 提交的是 mutations，而不是直接变更状态。也就是说，actions会通过mutations，让mutations帮他提交数据的变更。<br>
2.Action 可以包含任意异步操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue - 知识点大汇总]]></title>
        <id>https://xxliud.github.io/post/vue-knowledge/</id>
        <link href="https://xxliud.github.io/post/vue-knowledge/">
        </link>
        <updated>2020-06-24T14:29:12.000Z</updated>
        <content type="html"><![CDATA[<p>[ * ] <a href="https://xxliud.github.io/post/vue-vuex" title="vue-store">vue-store</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - 金丝雀发布]]></title>
        <id>https://xxliud.github.io/post/k8s-gray/</id>
        <link href="https://xxliud.github.io/post/k8s-gray/">
        </link>
        <updated>2020-06-23T16:16:43.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>确认istio-ingressgateway是否有对外的IP</li>
</ul>
<pre><code class="language-shell">kubectl get  service istio-ingressgateway -n istio-system
</code></pre>
<ul>
<li>编辑EXTERNAL-IP，写入ClusterIP为外网ip</li>
</ul>
<pre><code class="language-shell">kubectl edit  service istio-ingressgateway -n istio-system
</code></pre>
<ul>
<li>建立deployment</li>
</ul>
<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-app-1
spec:
  replicas: 1
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: &quot;true&quot;
      labels:
        app: nginx-app
        version: v1
    spec:
      containers:
        - name: nginx-app-1
          image: datacenter:v0.0.1
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 80
---

apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-app-2
spec:
  replicas: 1
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: &quot;true&quot;
      labels:
        app: nginx-app
        version: v2
    spec:
      containers:
        - name: nginx-app-2
          image: datacenter:v0.0.2
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 80
</code></pre>
<ul>
<li>建立service</li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
  labels:
    svcname: nginx-svc
spec:
  ports:
  - port: 8088
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx-app
</code></pre>
<ul>
<li>建立gateway</li>
</ul>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: nginx-gateway
spec:
  selector:
    istio: ingressgateway # use Istio default gateway implementation
  servers:
  - port:
      number: 80
      name: nginx-http
      protocol: HTTP
    hosts:
    - istio-zcbb.com
</code></pre>
<ul>
<li>建立VirtualService</li>
</ul>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: nginx-vs
spec:
  hosts:
  - istio-zcbb.com
  gateways:
  - nginx-gateway
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: nginx-svc
        subset: v1
      weight: 70
    - destination:
        host: nginx-svc
        subset: v2
      weight: 30
</code></pre>
<ul>
<li>建立DestinationRule</li>
</ul>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: nginx-app
spec:
  host: nginx-svc
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
</code></pre>
<pre><code class="language-shell">Istio Virtual Service，用于控制当前deployment和金丝雀deployment流量分配的权重
Istio Destination Rule，包含当前deployment和金丝雀deployment的子集（subset）
Istio Gateway（可选），如果服务需要从容器集群外被访问则需要搭建gateway
</code></pre>
<p>至此最简单的金丝雀发布完成，后期可以定制各种灰度策略</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s- 蓝绿发布]]></title>
        <id>https://xxliud.github.io/post/k8s-blue-green/</id>
        <link href="https://xxliud.github.io/post/k8s-blue-green/">
        </link>
        <updated>2020-06-23T16:05:29.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>实现原理，多pod，切换service verson指向</li>
<li>启动两个版本的deployment</li>
</ul>
<pre><code class="language-yaml">--- service 指向v1
apiVersion: v1
kind: Service
metadata:
  name: demo
  namespace: default
  labels:
    app: demo
spec:
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app: demo
    version: v1
--- depliyment v1
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo1-deployment
  namespace: default
  labels:
    app: demo
    version: v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: demo
      version: v1
  template:
    metadata:
      labels:
        app: demo
        version: v1
    spec:
      containers:
      - name: demo1
        image: database:v0.01
        ports:
          - name: http
            containerPort: 80
            protocol: TCP

--- depliyment v2
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo2-deployment
  namespace: default
  labels:
    app: demo
    version: v2
spec:
  replicas: 1
  selector:
    matchLabels:
      app: demo
      version: v2
  template:
    metadata:
      labels:
        app: demo
        version: v2
    spec:
      containers:
      - name: demo2
        image: database:v0.02
        ports:
          - name: http
            containerPort: 80
            protocol: TCP
</code></pre>
<ul>
<li>切换入口流量从v1 到 v2</li>
</ul>
<pre><code class="language-shell">kubectl patch service demo -p '{&quot;spec&quot;:{&quot;selector&quot;:{&quot;version&quot;:&quot;v2&quot;}}}'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - 安装ELK]]></title>
        <id>https://xxliud.github.io/post/k8s-elk/</id>
        <link href="https://xxliud.github.io/post/k8s-elk/">
        </link>
        <updated>2020-06-23T15:25:28.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>创建namespace elk</li>
</ul>
<pre><code class="language-shell">kubectl create namespace elk
</code></pre>
<ul>
<li>创建elasticsearch deployment service</li>
</ul>
<pre><code class="language-yaml">--- # elasticsearch deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: elasticsearch
  namespace: elk
  labels:
    app: elasticsearch
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
        hostname: elasticsearch
        containers:
         - image: elasticsearch:6.8.4
           imagePullPolicy: IfNotPresent
           name: elasticsearch
           ports:
             - name: es-port
               containerPort: 9200
             - name: es-tran-port
               containerPort: 9300

--- # elasticsearch service
apiVersion: v1
kind: Service
metadata:
  name: elasticsearch
  namespace: elk
  labels:
    name: elasticsearch
spec:
  type: NodePort
  ports:
  - port: 9200
    targetPort: 9200
    protocol: TCP
    nodePort: 30011
  selector:
    app: elasticsearch
</code></pre>
<ul>
<li>创建logstash deployment service, 配置文件参考之前文章</li>
</ul>
<pre><code class="language-yaml">--- # logstash deploy
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-logstash
  namespace: elk
  labels:
    app: my-logstash
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-logstash
  template:
    metadata:
      labels:
        app: my-logstash
    spec:
      containers:
        - name: my-logstash
          image: logstash:6.8.4
          imagePullPolicy: IfNotPresent
          ports:
          - containerPort: 5044
          volumeMounts:
          - name: log-config
            mountPath: /usr/share/pipeline
      volumes:
       - name: log-config
         hostPath:
          path: /Users/xingxu/elk/logstash/pipeline

--- # logstash service
apiVersion: v1
kind: Service
metadata:
  name: my-logstash
  namespace: elk
  labels:
    name: my-logstash
spec:
  type: NodePort
  ports:
  - port: 5044
    targetPort: 5044
    protocol: TCP
    nodePort: 30012
  selector:
    app: my-logstash
</code></pre>
<ul>
<li>创建kibana deployment service</li>
</ul>
<pre><code class="language-yaml">--- # kibana deploy
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-kibana
  namespace: elk
  labels:
    app: my-kibana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-kibana
  template:
    metadata:
      labels:
        app: my-kibana
    spec:
      containers:
        - name: my-kibana
          image: kibana:6.8.4
          imagePullPolicy: IfNotPresent
          ports:
          - containerPort: 5601

--- # kibana service
apiVersion: v1
kind: Service
metadata:
  name: my-kibana
  namespace: elk
  labels:
    name: my-kibana
spec:
  type: NodePort
  ports:
  - port: 5601
    targetPort: 5601
    protocol: TCP
    nodePort: 30010
  selector:
    app: my-kibana
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - zk&kafka安装]]></title>
        <id>https://xxliud.github.io/post/k8s-zk-kafka/</id>
        <link href="https://xxliud.github.io/post/k8s-zk-kafka/">
        </link>
        <updated>2020-06-23T14:56:48.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>创建zookerper deployment service</li>
</ul>
<pre><code class="language-yaml">--- # zk deploy
kind: Deployment
apiVersion: apps/v1
metadata:
  name: my-zk
  namespace: base
  labels:
    app: my-zk
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-zk
  template:
    metadata:
      labels:
        app: my-zk
    spec:
      hostname: my-zk
      dnsPolicy: ClusterFirst
      containers:
      - name: my-zk
        image: zookeeper
        imagePullPolicy: IfNotPresent
        volumeMounts:
        ports:
        - containerPort: 2181
        - containerPort: 2888
        - containerPort: 3888

### zk service
---
apiVersion: v1
kind: Service
metadata:
  name: my-zk
  namespace: base
  labels:
    name: my-zk
spec:
  type: NodePort
  ports:
  - port:
    port: 2181
    targetPort: 2181
    protocol: TCP
        nodePort: 30001
  selector:
    app: my-zk
</code></pre>
<ul>
<li>创建kafka deployment service</li>
</ul>
<pre><code class="language-yaml">--- # kafka deploy
kind: Deployment
apiVersion: apps/v1
metadata:
  name: my-kafka
  namespace: base
  labels:
    app: my-kafka
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-kafka
  template:
    metadata:
      labels:
        app: my-kafka
    spec:
      hostname: my-kafka
      dnsPolicy: ClusterFirst
      containers:
      - name: my-kafka
        image: wurstmeister/kafka
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 9092
        env:
        - name: KAFKA_ZOOKEEPER_CONNECT
          value: 'my-zk.base:2181'
        - name: KAFKA_ADVERTISED_HOST_NAME
          value: 'ClusterIP'
        - name: KAFKA_ADVERTISED_PORT
          value: 'NodePort'

--- # kafka service
apiVersion: v1
kind: Service
metadata:
  name: my-kafka
  namespace: base
  labels:
    name: my-kafka
spec:
  type: NodePort
  ports:
  - port: 9092
    targetPort: 9092
    protocol: TCP
    nodePort: 30002
  selector:
    app: my-kafka
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - Mongo安装篇]]></title>
        <id>https://xxliud.github.io/post/k8s-mongo/</id>
        <link href="https://xxliud.github.io/post/k8s-mongo/">
        </link>
        <updated>2020-06-23T14:38:49.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>创建namespace</li>
</ul>
<pre><code class="language-shell">kubectl create namespace base
</code></pre>
<ul>
<li>创建deployment service</li>
</ul>
<pre><code class="language-yaml">--- # mongo deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-mongo
  namespace: base
  labels:
    app: my-mongo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-mongo
  template:
    metadata:
      labels:
        app: my-mongo
    spec:
      containers:
      - name: my-mongo
        image: mongo
        ports:
        - containerPort: 27017

---  # mongo service
apiVersion: v1
kind: Service
metadata:
  name: my-mongo
  namespace: base
  labels:
    name: my-mongo
spec:
  type: NodePort
  ports:
  - port: 27017
    targetPort: 27017
    protocol: TCP
    nodePort: 30000
  selector:
    app: my-mongo
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - 学习资料汇总]]></title>
        <id>https://xxliud.github.io/post/k8s/</id>
        <link href="https://xxliud.github.io/post/k8s/">
        </link>
        <updated>2020-06-23T12:52:02.000Z</updated>
        <content type="html"><![CDATA[<p>[ * ] <a href="https://xxliud.github.io/post/minikube-install" title="minikube-install">Mac Install Minikube</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-mongo" title="k8s-mongo">K8s Install Mongo</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-zk-kafka" title="k8s-zk-kafka">K8s Install Zookerper Kafka</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-elk" title="k8s-elk">K8s Install ELK</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-istio" title="k8s-istio">Install Istio</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-blue-green" title="k8s-blue-green">K8s Bule Green Release</a><br>
[ * ] <a href="https://xxliud.github.io/post/k8s-gray" title="k8s-gary">K8s Gray Release</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s - Minikube安装篇]]></title>
        <id>https://xxliud.github.io/post/minikube-install/</id>
        <link href="https://xxliud.github.io/post/minikube-install/">
        </link>
        <updated>2020-06-23T12:52:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是k8s">什么是k8s</h2>
<p>我们知道，我们可以将项目制作成docker镜像，然后利用docker去部署我们的项目，这样可以解决很多服务器环境所带来的问题；<br>
但是容器多了，容器与容器之间就需要访问，之间就需要网络配置等等，从而就有了docker-compose；<br>
但是当我们的服务进行升级，或者服务需要进行调度，扩容等等，这个时候就需要一个大管家来管所有的东西；<br>
这个大管家就是 - Kubernetes</p>
<h2 id="mac安装kubernetes单节点minikube">mac安装kubernetes单节点minikube</h2>
<ul>
<li>安装kubectl 核心操作管理命令</li>
</ul>
<pre><code class="language-shell">brew install kubernetes-cli
</code></pre>
<ul>
<li>安装minikube</li>
</ul>
<pre><code class="language-shell">brew cask install minikube
</code></pre>
<ul>
<li>启动minikube</li>
</ul>
<pre><code class="language-shell">minikube start -p docker镜像仓库
Starting local Kubernetes v1.10.0 cluster...
Starting VM...
Getting VM IP address...
Moving files into cluster...
Setting up certs...
Connecting to cluster...
Setting up kubeconfig...
Starting cluster components...
Kubectl is now configured to use the cluster.
Loading cached images from config file.
</code></pre>
<ul>
<li>查看kubernetes的dashboard</li>
</ul>
<pre><code class="language-shell">minikube dashboard
</code></pre>
<p>至此minikube搭建完成</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们与ELK的距离]]></title>
        <id>https://xxliud.github.io/post/docker-elk/</id>
        <link href="https://xxliud.github.io/post/docker-elk/">
        </link>
        <updated>2020-06-23T12:24:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>对ELK的了解一直都停留在高大上的感觉，公司有专门的部分搞，也曾经在19年1月份的时候，利用过年闲暇时间尝试搭建，但是失败了，回想发现如果当时不是走捷径直接拉取elk的组合镜像包，可能早就成功了，还是那句话，什么都没有捷径...</p>
<h2 id="搭建过程">搭建过程</h2>
<p><img src="https://xxliud.github.io/post-images/1592915083405.jpg" alt="" loading="lazy"><br>
ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。市面上也被成为Elastic Stack。其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es。Logstash是ELK的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等）。Kibana可以将elasticsearch的数据通过友好的页面展示出来，提供实时分析的功能。</p>
<p>下面简单介绍一下docker下如何搭建elk平台</p>
<p>我们的架构图：<br>
<img src="https://xxliud.github.io/post-images/1592915101615.png" alt="" loading="lazy"></p>
<p>下面我们使用docker进行搭建</p>
<ul>
<li>创建网络</li>
</ul>
<pre><code class="language-shell">docker network create somenetwork
</code></pre>
<ul>
<li>拉取需要的镜像</li>
</ul>
<pre><code class="language-shell">docker pull zookeeper:latest   # zk
docker pull wurstmeister/kafka:latest  # kafka
docker pull elasticsearch:6.8.4  # es
docker pull logstash:6.8.4  # logstash
docker pull kibana:6.8.4   #kibana
</code></pre>
<ul>
<li>创建zk + kafka</li>
</ul>
<pre><code class="language-shell"># zookeeper
docker run -d --name zookeeper \
--publish 2181:2181  zookeeper:latest

# kafka
docker run -d --name kafka --publish 9092:9092 \
--link zookeeper \
--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \
--env KAFKA_ADVERTISED_HOST_NAME=kafka所在宿主机的IP \
--env KAFKA_ADVERTISED_PORT=9092 \
--net somenetwork
wurstmeister/kafka:latest


# 测试
docker exec -it kafka /bin/bash
# 进入bin目录
cd /opt/kafka_2.25-2.3.0/bin/
# 创建topic
./kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic elk-kafka-test 
# 运行生产者并指定topic
./kafka-console-producer.sh --broker-list 127.0.0.1:9092 --topic elk-kafka-test 
# 新开窗口运行消费者，指定同样的topic， 注意替换kafkaIp
./kafka-console-consumer.sh --bootstrap-server kafkaIp:9092 --topic elk-kafka-test --from-beginning
</code></pre>
<ul>
<li>Elasticsearch 安装</li>
</ul>
<pre><code class="language-shell">docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:6.8.4
</code></pre>
<p>验证 curl http://localhost:9200<br>
<img src="https://xxliud.github.io/post-images/1592915628111.jpg" alt="" loading="lazy"></p>
<ul>
<li>Kibana 安装</li>
</ul>
<pre><code class="language-shell">docker run -d --name kibana --net somenetwork -p 5601:5601 kibana:6.8.4
</code></pre>
<p>验证 浏览器访问 http://localhost:5601<br>
<img src="https://xxliud.github.io/post-images/1592915675748.jpg" alt="" loading="lazy"></p>
<ul>
<li>Logstash 安装<br>
vim vim logstash.conf/logstash.conf</li>
</ul>
<pre><code class="language-shell">input {
   kafka {
     bootstrap_servers =&gt; [&quot;kafka:9092&quot;]
     auto_offset_reset =&gt; &quot;latest&quot;
     consumer_threads =&gt; 5
     decorate_events =&gt; true
     group_id =&gt; &quot;elk&quot;
     topics =&gt; [&quot;elk_kafka_test&quot;]
     type =&gt; &quot;bhy&quot;
     codec =&gt; json {
             charset =&gt; &quot;UTF-8&quot;
     }
   }
}

output {
   stdout {}
   elasticsearch {
     hosts =&gt; [&quot;elasticsearch:9200&quot;]
     index =&gt; &quot;test-elk-%{+YYYY.MM.dd}&quot;
   }
}
</code></pre>
<pre><code class="language-shell">docker run -it -d -p 5044:5044 --name logstash \
--net somenetwork --link kafka --link elasticsearch \
-v c:/usr/share/pipeline logstash:6.8.4
</code></pre>
<ul>
<li>FileBeat 配置监听<br>
编辑filebeat.yml</li>
</ul>
<pre><code class="language-shell">filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /data/log/*.log
  fields:
    docType: sys-log

output.kafka:
  hosts: [&quot;kafkaIp:9092&quot;]
  topic: &quot;elk_kafka_test&quot;
</code></pre>
<p>启动filebeat</p>
<pre><code class="language-shell">./filebeat -c filebeat.yml -e
</code></pre>
<p>在/data/log/目录下变更日志文件，filebeat监听到变化，将日志在kafka中生产待logstash进行消费，在logstash容器内可以看到日志转换成json格式的数据存储到logstash里<br>
<img src="https://xxliud.github.io/post-images/1592915981638.jpg" alt="" loading="lazy"><br>
在kibana中查看<br>
<img src="https://xxliud.github.io/post-images/1592915998023.jpg" alt="" loading="lazy"><br>
至此ELK搭建完成</p>
]]></content>
    </entry>
</feed>